#!/usr/local/bin/pscript

userlog("Provision script started");

print("\n");
print("    ______          __                    ___  __\n");
print("   / ____/___  ____/ /_  ___________    _/_/ |/ /\n");
print("  / __/ / __ \\/ __  / / / / ___/ __ \\ _/_/ |   / \n");
print(" / /___/ / / / /_/ / /_/ / /  / /_/ //_/  /   |  \n");
print("/_____/_/ /_/\\__,_/\\__,_/_/   \\____/_/   /_/|_|  \n");
print("\n");
print("                     Provision\n");
print("\n");

//Provision class
class Provision {

	//Should come from packages
	osType = "";
	
	//Queue type...
	qType = "";
	
	//Queue prefix
	</ order=0, name = "Queue device path", type = "string", min=1, max=512 /> 
	qpath = "/dev/mqueue";
	
	//Get some random number...
	</ order=1, name = "Cluster node id", type = "number", min=1, max=32 /> 
	nodeid = "1";
	
	</ order=2, name = "System code (prefix/setfile name, etc)", type = "string",
                min=1, max=8, regex="^[A-Za-z0-9]+"/> 
	qprefix = "test1";
	
	</ order=3, name = "Setup sample XA config", type = "yn"/> 
	sampleXA = "n";
	
	</ order=4, name = "Application home", type = "string", min=1, max=512, regex="^/.*" /> 
	appHome = "";
	
	//If starts with '/' - then assume that it is full path...
	</ order=6, name = "Executables/binaries sub-folder of Apphome", type = "path"/> 
	binDir = "bin";
	
	</ order=7, name = "Configuration sub-folder of Apphome", type = "path"/> 
	binDir = "conf";
	
	</ order=8, name = "Log sub-folder of Apphome", type = "path"/> 
	confDir = "conf";
	
	</ order=9, name = "Log sub-folder of Apphome", type = "path"/> 
	logDir = "log";
	
	</ order=10, name = "Temp sub-dir (used for pid file)", type = "path"/> 
	tempDir = "tmp";
	
	</ order=11, name = "System wide tpcall() timeout", type = "number"/> 
	timeout = "60";
	
	</ order=12, name = "Install sample queue configuration", type = "yn"/> 
	installQ = "y";
	
	</ order=13, name = "Install event server", type = "yn"/> 
	eventSv = "y";
	
	</ order=14, name = "Configure Client Process Monitor Server", type = "yn"/> 
	cpmSv = "y";
	
	</ order=15, name = "Install Configuration server", type = "yn"/> 
	configSv = "y";
	
	</ order=16, name = "Install bridge connection", type = "yn"/> 
	bridge = "y";
	
	</ order=17, name = "Bridge -> Role: Active(a) or passive(p)?", type = "string", 
                regex="^[apAP]?", depend="::prov.bridge==\"y\""/> 
	bridgeRole = "a";

	</ order=18, name = "Bridge -> IP: Listen address", type = "regex", 
                regex="^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$", depend="(::prov.bridge==\"y\" && ::prov.bridgeRole==\"p\")"/> 
	ipl = "0.0.0.0";
	
	</ order=19, name = "Bridge -> IP: Connect to", type="regex", regex="^(?:[0-9]{1,3}\\.){3}[0-9]{1,3}$", 
                depend="(::prov.bridge==\"y\" && ::prov.bridgeRole==\"a\")"/> 
	ipc = "172.0.0.1";
	
	</ order=20, name = "Bridge -> IP: Port number", type="number", min=0, max=65000, 
                depend="(::prov.bridge==\"y\")" /> 
	port = "21003";
	
	</ order=21, name = "Other cluster node id", type="number", min=1, max=32, 
                depend="(::prov.bridge==\"y\")" /> 
	otherNodeId = "2";
	
	</ order=22, name = "CCTag (use if set)", type="string", min=0, max=8, regex="[^/]*" /> 
	cctag = "";
	
	</ order=23, name = "IPC Key used for System V semaphores", 
			type="string", regex="[0-9a-fA-F]+" min=1, max=8 /> 
	ipckey = "44000";
	
	//Install handler
	install = null;
	
	elemOrder = null;
	
	isDefaulted = false;
	
	//Calculated min/max order
	minOrder = 99;
	
	maxOrder = -1;
	
	
	//This is constructor, we shall get some infos from Enduro/X base build
	constructor() {
		osType = getosname();
		//qType = "posixq";
		
		//Set app home to pwd
		appHome = getcwd();
		
		elemOrder = this.getSortedParamArray();
		
		
	}
	
	//Print the value entry line
	function printEntryLine(pfx, member) {
	
		local attr = this.getclass().getattributes(member);
		::print(format("%2s:%s %-12s :%s [%s]: ", ""+attr["order"], pfx,
				member, attr["name"], this[member]));
				
		::userlog(format("%2s:%s %-12s :%s [%s]: ", ""+attr["order"], pfx,
				member, attr["name"], this[member]));
	}
	
	//Validate the value of field
	//@param member	Class member to attributes from
	//@param value	Value to test validity for this field
	function validateValue(member, value)
	{
	
		local attr = Provision.getattributes(member);
		local empty = false;
		if (attr["type"]=="number")
		{
			if (attr.rawin("min"))
			{
				if ((value.tointeger()) < (attr["min"]))
				{
					print("Invalid value: Min length "+attr["min"]+"\n");
					return 0;
				}
			}
			
			if (attr.rawin("max"))
			{
				if ((value.tointeger()) > (attr["max"]))
				{
					print("Invalid value: Max length "+attr["max"]+"\n");
					return 0;
				}
			}
		}
		else
		{
			if (attr.rawin("min"))
			{
			
				if (value.len() < attr["min"])
				{
					print("Invalid value: Min length "+attr["min"]+"\n");
					return 0;
				}
				
				if (0==attr["min"])
				{
					empty=true;
				}
			}
			
			if (attr.rawin("max"))
			{
				if (value.len() > (attr["max"]+0))
				{
					print("Invalid value: Max length "+attr["max"]+"\n");
					return 0;
				}
			}
		}
		
		//Check for regex
		if (!empty && attr.rawin("regex"))
		{
		
			local ex = regexp(attr["regex"]);
			
			if (!ex.match(value))
			{
				print("Invalid value: Does not match expression: ["+
					attr["regex"]+"]\n");
				return 0;
			}
		}
		
		if (attr["type"]=="yn")
		{
		
			local ex = regexp("^[ynYN]$");
			
			if (!ex.match(value))
			{
				print("Error: Y/N?\n");
				return 0;
			}
		}
		
		return 1;
	}
	
	//Returns elements in sorted order
	function getSortedParamArray()
	{
		local elemOrder = [];
		//prov.install.CheckLimits();

		//Sort the fields
		foreach(member,val in Provision)
		{
			local attr = Provision.getattributes(member);
			
			if (null!=attr)
			{	
				if (attr["order"]<minOrder)
				{
					minOrder = attr["order"];
				}
				
				if (attr["order"]>maxOrder)
				{
					maxOrder = attr["order"];
				}

				elemOrder.append(member);
			}
		}

		//Now sort the array
		//TODO: Move to class...
		elemOrder.sort(function(a,b)
		{
			local attrA = Provision.getattributes(a);
			
			local attrB = Provision.getattributes(b);

			return attrA["order"] <=> attrB["order"];
		} );
		
		return elemOrder;
	}
	
	
	//Test is field actual of the object
	//@param member	Field to test for need
	//@return TRUE field actual for user intervetion, FALSE not needed for user.
	function isFieldActual(member)
	{
		local attr;
		
		attr = Provision.getattributes(member);
		
		//Check that dependency is ok
		if (attr.rawin("depend"))
		{
			local compiledscript = compilestring("return "+attr["depend"]+";");
			return compiledscript();
		}
		else
		{
			return true;
		}
	}
	
	//Enter the field value from console
	//@param member 	Field to enter.
	function enterField(member)
	{
		local ok = false;
				
		while (!ok)
		{
			this.printEntryLine("", member);

			local new_val  = getline();
			
			if (new_val=="")
			{
				new_val = this[member];
			}
			
			//Validate input...
			if (this.validateValue(member, new_val))
			{
				this[member] = new_val;
				ok = true;
			}
		}
	}
	
	//Run the runInteractive configuration
	//@return TRUE OK to provision (accepted), FALSE - not ok
	function runInteractive()
	{
		//Run the wizzard...
		//Iterate over the all paramters
		//foreach(member,val in Provision)
		foreach(member in elemOrder)
		{
			if (this.isFieldActual(member))
			{
				enterField(member);
			}
		}

		//OK to provision..
		return true;
	}
	
	
	//Get element name by order
	//@param order	Order number of attributes
	//@return	element name, empty if not found
	function getMemberByOrder(order)
	{
		foreach(member,val in Provision)
		{
			local attr = Provision.getattributes(member);
			
			if (null!=attr)
			{	
				if (attr["order"] == order.tointeger())
				{
					if (this.isFieldActual(member))
					{
						return member;
					}
					else
					{
						return ""; /* currently not editable... */
					}
						
				}
			}
		}
		
		return "";
	}
	
	
	//Print the actual configuration
	//@return true - config ok, false - config bad
	function printConfig()
	{
		//Run the wizzard...
		//Iterate over the all paramters
		//foreach(member,val in Provision)
		foreach(member in this.elemOrder)
		{
			if (this.isFieldActual(member))
			{
				
				if (!this.validateValue(member, this[member]))
				{
					return false;
				}
			
				//Validate input...
				//Print the field value
				this.printEntryLine(" Edit", member);
				print("\n");
			}
		}
		
		return true;
	}
	
	
	//Validate and print config
	function validatAndPrintConfig()
	{
		while (1)
		{
			print("\n");
			print("*** Review & edit configuration ***\n");
			print("\n");
			
			if (!printConfig())
			{
				return false;
			}
					
			//If not defauled, then allow to edit the some entry...
			if (!isDefaulted)
			{
				//Offer entry...
				::print("91: Cancel\n");
				::print("92: Accept\n");
				::print("Enter the choise ["+minOrder+"-"+maxOrder+", 91, 92]: ");
				
				local input = getline();
				
				userlog("User entered: "+input);
				if (input=="91")
				{
					userlog("Terminating...");
					return false;
				}
				else if (input=="92")
				{
					userlog("Accepted");
					return true;
				}
				else if (input!="")
				{
					/* Check the range */
					local ok = false;
					
					local member = "";
					while (!ok)
					{
						member = getMemberByOrder(input);
						
						if (member=="")
						{
							::print("Invalid entry\n");
							::print("Enter the choise ["+
								minOrder+"-"+maxOrder+", 91, 92]: ");
							input = getline();
						}
						else
						{
							ok = true;
						}
					}
					
					/* edit the field */
					enterField(member);
				}	
			}
		}
		
		//OK to provision..
		return true;
	}
	
	//Get the output files to write to
	//So we will need following:
	//1. ndrxconfig.xml
	//2. app.ini
	//3. setqprefix
	
	ndrxconfig = "";
	appini = "";
	setfile = "";
	
	function getOutputFiles()
	{
		ndrxconfig = appHome+"/"+confDir+"/ndrxconfig.xml";
		appini = appHome+"/"+confDir+"/app.ini";
		setfile = appHome+"/"+confDir+"/set"+qprefix;
		
		print("ndrxconfig: ["+ndrxconfig+"]\n");
		userlog("ndrxconfig: ["+ndrxconfig+"]");
		
		print("appini: ["+appini+"]\n");
		userlog("appini: ["+appini+"]");
		
		print("setfile: ["+setfile+"]\n");
		userlog("setfile: ["+setfile+"]");
	}
	
	
	//Build the ndrxconfig value
	ndrxconfigVal = "";
	function buildNdrxconfig()
	{
	
		local xmlStart = @"
<?xml version=""1.0"" ?>
<endurox>
	<!--
			*** For more info see ndrxconfig.xml(5) man page. ***
	-->
	<appconfig>
	
		<!-- 
			ALL BELLOW ONES USES <sanity> periodical timer  -->
			Sanity check time, sec
		-->
		<sanity>5</sanity>
		
		<!--
			Seconds in which we should send service refresh to other node.
		-->
		<brrefresh>6</brrefresh>
		
		<!-- 
			Do process reset after 1 sec 
		-->
		<restart_min>1</restart_min>
		
		<!-- 
			If restart fails, then boot after +5 sec of previous wait time
		-->
		<restart_step>1</restart_step>
		
		<!-- 
			If still not started, then max boot time is a 30 sec. 
		-->
		<restart_max>5</restart_max>
		
		<!--  
			<sanity> timer, usage end
		-->
		
		<!-- 
		Time (seconds) after attach when program will start do sanity & respawn checks,
		starts counting after configuration load 
		-->
		<restart_to_check>20</restart_to_check>
		
		
		<!-- 
			Setting for pq command, should ndrxd collect service 
			queue stats automatically If set to Y or y, 
			then queue stats are on. Default is off.
		-->
		<gather_pq_stats>Y</gather_pq_stats>
		
	</appconfig>
	<defaults>
	
		<min>1</min>
		<max>2</max>
		
		<!-- 
			Kill the process which have not started in <start_max> time
		-->
		<autokill>1</autokill>
		
		<!-- 
			The maximum time while process can hang in 'starting' state i.e.
			have not completed initialization, sec X <= 0 = disabled  
		-->
		<start_max>2</start_max>
		
		<!--
			Ping server in every X seconds (step is <sanity>).
		-->
		<pingtime>10</pingtime>
		
		<!--
			Max time in seconds in which server must respond.
			The granularity is sanity time.
			X <= 0 = disabled 
		-->
		<ping_max>40</ping_max>
		
		<!--
			Max time to wait until process should exit on shutdown
			X <= 0 = disabled 
		-->
		<end_max>30</end_max>
		
		<!-- 
			Interval, in seconds, by which signal sequence -2, -15, -9, -9.... will be sent
			to process until it have been terminated.
		-->
		<killtime>1</killtime>
		
	</defaults>
	<servers>";
	
		//Install config server
		if (configSv=="Y" || configSv=="y")
		{
		
			xmlStart=xmlStart+
		@"
		<server name=""cconfsrv"">
			<min>2</min>
			<max>2</max>
			<srvid>1</srvid>
			<sysopt>-e ${NDRX_APPHOME}/"+logDir+@"/cconfsrv.log -r</sysopt>
		</server>";
		
		}
		
		//Install event server
		if (eventSv=="Y" || eventSv=="y")
		{
		
			xmlStart=xmlStart+
		@"
		<server name=""tpevsrv"">
			<min>2</min>
			<max>2</max>
			<srvid>100</srvid>
			<sysopt>-e ${NDRX_APPHOME}/"+logDir+@"/tpevsrv.log -r</sysopt>
		</server>";
		}
		
		//Cluster bridge connection
		if (eventSv=="Y" || eventSv=="y")
		{
		
			//TODO:
			xmlStart=xmlStart+
		@"
		<server name=""tpbridge"">
			<min>1</min>
			<max>1</max>
			<srvid>150</srvid>
			<sysopt>-e ${NDRX_APPHOME}/"+logDir+@"/tpbridge_"+otherNodeId+@".log -r</sysopt>
			<appopt>-f -n"+otherNodeId+@" -r -i 127.0.0.1 -p 44002 -t"+bridgeRole.toupper()+@" -z30</appopt>
		</server>";
		}
		
		
		
		print(xmlStart);
	
	}
	
	
	//Build the app.ini value
	appiniVal = "";
	function buildAppini()
	{
		
	}
	
	
	setfileVal = "";
	function buildSetfile()
	{
		
	}
	
}

local root = getroottable()

//Create a provision object
root["prov"] <- Provision();


print("Compiled system type....: " + ::prov.osType + "\n");
print("Queueing mechanism......: " + ::prov.qType + "\n");
print("\n");

::prov.runInteractive();
if (::prov.validatAndPrintConfig())
{
	::prov.getOutputFiles();
	::prov.buildNdrxconfig();
	::prov.buildAppini();
	::prov.buildSetfile();
}


