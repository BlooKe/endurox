EnduroX Internal Develper Guide
===============================
Madars Vitolins
v1.0, 2012-12:
	Initial draft
:doctype: book

EnduroX Development standard
----------------------------
EnduroX build system is CMake. Version used should be 2.8 and above. It uses
Flex and Bison for building UBF (FML) Expressions.

Intension is done with as 4x spaces. EnduroX is programmed in NetBeans c/c++
project. NetBeans supports CMake projects.

Project also uses 'libxml2' (provided by system), 'exhash' (already included in 'include' dir) 
and cgreen (integrated into Enduro/X) for unit testing.

Unit testing
------------

Bot UBF and ATMI sub-systems are unit tested. UBF tests are located under 
'ubftest' folder, which could be run by:

--------------------------------------------------------------------------------
$ ./ubfunit1 2>/dev/null
Running "main"...
Completed "main": 5749 passes, 0 failures, 0 exceptions.
--------------------------------------------------------------------------------

ATMI tests are located at 'atmitest' directory, can be run by:
--------------------------------------------------------------------------------
$ ./run.sh 
tail -n1 test.out
Completed "main": 18 passes, 0 failure, 0 exceptions.
--------------------------------------------------------------------------------


Enduro/X libraries
------------------

The framework is composed by following internal libraries and it's dependencies:
[dia, module_dependency.dia, module_dependency.png, x300]
-------------------------------
-------------------------------

Common configuration
--------------------

Enduro/X users are welcome to use common configuration engine. This engine uses
ini files to get key/values from ini section (and subsection with inheritance).
The configuration can point to directory and in that case Enduro/X will read the
all configuration files in directory which ends with with ".ini .cfg, .conf, .config".
Configuration engine will automatically detect that given resource is directory
and will start to scan for files in directory.

The library keeps all ini file data in memory in hash tables, which also can be iterated
as the linked lists. The library can be instructed to refresh the memory configuration.
Refresh function detects any files changed in disk (by time stamp) and reload the data
in memory.

=== Enduro/X common config setup

Enduro/X can be configured by using ini file (or files) instead of environment variables, 
ndrxdebug.conf and q.conf.
Two new environment variables now are added to the system:

1. NDRX_CCONFIG=/path/to/ini/file/or/directory/with/files 

2. And optional NDRX_CCTAG which allows processes to specify the subsection of Enduro/X system settings.

The configurations sections are:

- [@global] - environment variables for process (see ex_env(5))

- [@debug] - debug configuration per binary (see ndrxdebug.conf(5))

- [@queue] - persistent queue configurations.

If you use NDRX_CCTAG or specify the "cctag" for ATMI server, then Enduro/X 
will scan for sections like (e.g. cctag=TAG1):

- [@global/TAG1] and then [@global]

- [@debug/TAG1] and then [@debug]

- [@queue/TAG1] and then [@debug]

cctag can contain multiple tags, which are separated by '/'.
In that case multiple lockups will be made with base section combination.

=== User accessible configuration server

"cconfsrv" XATMI server which can be used by applications to use Enduro/X 
framework for application configuration. The user application can call the 
"@CCONFIG" server in two modes:

A) for getting the exact section;

B) for listing the sections.

See cconfsrv(8) for more details. 

The idea behind this is that user can do the programming under Enduro/X in
 multiple languages (C/Go/Perl/Python/PHP/NodeJs) and these modules typically
needs configuration. It would be waste of time if for each of the languages
developer would need to think how to read the configuration from configuration
files with native libraries. The Enduro/X offers standard XATMI micro-service 
call for reading the ini files in common way for whole application,
no matter in which language it is programmed.

But C/C++ programmers can use Enduro/X direct libraries for configuration processing.
See the 'atmitest/test029_inicfg/atmiclt29.c' for sample code.


=== Common configuration internals
The configuration driving is built in multiple layers:

- Layer 1: Physical file reading by "ini.h" library which gives the 
callback for any parsed key/value/section;

- Layer 2: Enduro/X code named "inicfg.h" and "inicfg.c". This drives the configuration
object loads files into memory. Performs the refreshes, resolves the sections (with inheritance).
Returns the buffers with values.

- Layer 3: High level configuration driving by "cconfig.h" and "cconfig.c". This operates
with Enduro/X environment variables and Enduro/X configuration files.
However you may use different env variables for different purposes. For example:
"NDRX_CCONFIG" variable can point to Enduro/X config, but "NDRX_CCONFIG1" can point to your
application configuration. And this still is valid setup and keeps files separate.

- Layer 4: "cconfsrv". This is high level API, accessible by transaction protocol (TP)
sub-system. See the cconfsrv(8) manpage. Internally is uses Layer 2 and 3 API.

[dia, common_config.dia, common_config.png, x450]
-------------------------------
-------------------------------

Common Debug logging API - TPLOG
--------------------------------

Enduro/X offer debug logging facility named "TPLOG". TPLog basically stands for extended
user log. The user applications can use this API to configure TPLog, NDRX and UBF logs to
be redirect to specified files, configure levels. Enduro/X introduces concept of request
logging which means that each system request (or session) which processes UBF buffers can
be logged to separate file. Which basically redirects NDRX, UBF and TPLog (user) to specific
file. File can be set by *tplogsetreqfile(5)*.

=== Logging facilities 

- 'NDRX', logging facility code 'N' - this is Enduro/X XATMI framework internal debug logging.
Debug string setting for level is set with keyword 'ndrx'. Facility is defined with macros
*LOG_FACILITY_NDRX*.

- 'UBF', logging facility code 'U' - this is UBF library logs. In debug string level is set with
keyword 'ubf'. Facility is defined with macros *LOG_FACILITY_UBF*.

- 'TP', logging facility code 't' - this is user logs. In debug string level is set with
keyword 'tp'. facility is defined with macros *LOG_CODE_TP*. This is logging process based logging.

- 'TP_THREAD', logging facility code 'T' - this is user logs, set on per thread basis. The log level
is set with keyword 'tp'.

- 'TP_REQUEST', logging facility code 'R' - this is user logs, set on per thread/request basis. The log level
is set with keyword 'tp'.

=== Hierarchy of the  loggers (facilities)

The loggers output the debug content in following order of the facilities status:

- If 'TP_REQUEST' is open (debug file set), then all logging (NDRX, UBF, TP) will go here.
The debug level is shared at application level with NDRX, UBF and TP facilities. There will be no
impact if 'TP_REQUEST' log level is different.

- If 'TP_THREAD' is open (debug file set), then ...


=== Debug string format

>>TODO<<

=== Logging functions

This chapter will make a short list and description of API functions available for debug
logging.

>>TODO<<


Queuing mechanisms
------------------

Enduro/X originally was developed for GNU/Linux kernels where resource polling sub-system
i.e. epoll() can handle Posix queue handlers. This is linux non-standard feature which 
greatly supports system development. This allows to build one queue - multiple servers
architecture (even for ATMI server processes waiting on different queues). However, this
this feature limits platform to be working on Linux only.

[dia, epoll_message_dispatch_mode.dia, epoll_message_dispatch_mode.png, x300]
-------------------------------
-------------------------------

Starting from Enduro/X version 3, there is support for other Posix compatible Operating
Systems. Where possible Posix queues are used. If no Queueu support built in, for example
Apple OSX, then emulated Posix queues are used. For these platforms, the caller processes
does choose the queue where to send the message in round-robin mode. For each service
shared memory contains list of server IDs providing the service. In round robin mode
the server id is selected, and caller sends the service to queue (e.g. 'dom1,svc,TESTSVC,102'
where '102' is server id.).

[dia, poll_message_dispatch_mode.dia, poll_message_dispatch_mode.png, x450]
-------------------------------
-------------------------------

For other unix support, mq_notify() call for each open queue is installed, by employing
SIGUSR2. Signal handling is done in seperate thread. The main ATMI server thread is doing
'poll()' in unnamed pipe. When event from mq_ sub-system is received, it writes the queue
descriptor id to unnamed pipe and that makes main thread to wake up for queue processing.
The 'poll()' for main thread supports Enduro/X extensions to add some other resource for
polling (e.g. socket fd.)

:numbered!:

[bibliography]
Additional documentation 
------------------------
This section lists additional related documents.

[bibliography]
.Internet resources
- [[[ATMI-API]]] http://docs.oracle.com/cd/E13203_01/tuxedo/tux71/html/pgint6.htm
- [[[FML-API]]] http://docs.oracle.com/cd/E13203_01/tuxedo/tux91/fml/index.htm

[glossary]
Glossary
--------
This section lists

[glossary]
ATMI::
  Application Transaction Monitor Interface

UBF::
  Unified Buffer Format it is similar API as Tuxedo's FML


////////////////////////////////////////////////////////////////
The index is normally left completely empty, it's contents being
generated automatically by the DocBook toolchain.
////////////////////////////////////////////////////////////////
